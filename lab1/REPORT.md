# Отчет по лабораторной работе
## по курсу "Искусственный интеллект"

### Студенты: 

| ФИО       | Роль в проекте                     | Оценка       |
|-----------|------------------------------------|--------------|
| Меркулов Ф.А. | Инженер по знаниям: описание и реализация базы знаний предметной области "Алгоритмы": категорий: "Сортировка", "Сжатие Текста", "Поиск подстрок" |          |
| Лохматов Н.И. | Инженер по знаниям: описание и реализация базы знаний предметной области "Алгоритмы": категорий: "Графы", "Задача на оптимизацию", "Деревья" и "Сбалансированные деревья" |       |
| Павловский А.В. | Разработчик: реализовал оболочку ЭС на python: "Сортировка", "Сжатие Текста", "Поиск подстрок", исправление ошибок |       |
| Чубуков А.В. | Разработчик: реализовал оболочку ЭС на python: "Графы", "Задача на оптимизацию", "Деревья" и "Сбалансированные деревья", исправление ошибок |       | 
| Старцев И.Р. | Тестировщик: диагностировал оболочку ЭС на python: "Сортировка", "Сжатие Текста", "Поиск подстрок" |       | 
| Шашков Д.Д. | Тестировщик: диагностировал оболочку ЭС на python: "Графы", "Задача на оптимизацию", "Деревья" и "Сбалансированные деревья" |       | 
| Иванов Е.Д. | Технописец: структурирование материала, написание отчёта |          |


> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Тема работы

Разработка экспертной системы для классификации алгоритмов в информатике с целью выбора оптимального алгоритма для решения конкретной задачи

## Описание

В данной работе предлагается разработка экспертной системы, способной классифицировать алгоритмы и определять наиболее подходящий алгоритм для заданной задачи в области информатики. Предметная область охватывает ключевые категории алгоритмических задач, включая сортировку, сжатие текста, поиск подстрок, обработку графов, задачи на оптимизацию, операции с деревьями и сбалансированными деревьями. 

Система будет основываться на анализе характеристик входной задачи, включая её тип, ограничения и специфические требования. Эта система будет принимать набор фактов о задаче для выяснения её ключевых аспектов, после чего осуществляется оценка разнообразных алгоритмов с точки зрения их производительности, сложности выполнения и адаптивности к заданным условиям. Основная цель - автоматизировать процесс подбора алгоритма, что способствует увеличению продуктивности программистов и научных работников в сфере компьютерных наук. Система будет использовать метод прямого обхода для определения подходящего алгоритма на основе собранной информации о задаче.

## Концептуализация предметной области

В качестве рассматриваемых алгоритмов мы использовали:
1) Сортировки (быстрая(O(nlogn) из-за сравнений) и линейные(O(n)))
2) Нахождение кратчайшего расстояния в графе (Дейкстра, Флойд-Уоршал)
3) Бинарные деревья поиска (AVL, B-дерево, КЧ, Декартово, PATRICIA)
4) Анализ текста (Compact Trie, Суффиксное дерево, Ахо-Корасик)
5) Поиск подстроки в строке (БМ, КМП, АД, z-функция)
6) Задача на оптимизацию (ДП, ЖА)
7) Сжатие Текстов (Статическое, полустатическое, адаптивное) (Хаффман, Арифметическое, алгоритмы семейства LZ, RLE, move to front, предсказание по частичному совпадению, Барроуз-Уилер)
8) Минимальные остовные деревья

В процессе концептуализации предметной области экспертной системы по классификации алгоритмов были выявлены ключевые категории и подкатегории. Эти категории включают в себя: "Сортировку", "Сжатие текста", "Поиск подстрок", "Графы", "Задачи на оптимизацию", "Деревья" и "Сбалансированные деревья". Каждая из этих категорий далее подразделяется на более узкие подгруппы, основанные на специфических характеристиках и применениях алгоритмов. Например, категория "Сортировка" может включать в себя такие алгоритмы, как быстрая сортировка, сортировка слиянием, карманная сортировка, сортировка подсчётом и поразрядная сортировка. Система также учитывает факторы, такие как временная сложность и применимость алгоритмов в различных условиях, что позволяет ей точно определить наиболее подходящий алгоритм для решения конкретной задачи. В результате создается структурированная и иерархичная модель, обеспечивающая эффективный выбор и классификацию алгоритмов.

Учитывая, что последние два семестра каждый из нас изучал предмет "Дискретный анализ", наша команда находится в уникальном положении для коллективного вклада в создание базы знаний по алгоритмам. Благодаря этому обширному образовательному опыту, каждый участник команды накопил специализированные знания и понимание различных аспектов алгоритмов и их применений. Это позволило нам эффективно разделить предметную область на ключевые категории, соответствующие уникальным интересам и экспертизе каждого члена команды.

В общем виде графическое представление выглядит:
![image](https://github.com/MAILabs-Edu-2024/ai-lab-1-knowledge-representation-o-n-3-16/assets/114834766/9999d8df-330f-44de-8bf2-5132ff656818)


## Принцип реализации системы

В данной работе мы применили метод прямого вывода, который отличается своей способностью быстро и систематически генерировать новые знания и находить решения на их основе. Основные преимущества этого метода в экспертных системах включают:

Эффективность: Метод прямого вывода позволяет оперативно принимать решения, используя имеющиеся данные и правила вывода.

Простота Реализации: Этот метод является понятным и легким в применении, не требуя сложных математических вычислений или алгоритмов.

Гибкость Системы: Метод прямого вывода обладает гибкостью, так как позволяет легко модифицировать и добавлять новые правила вывода.

Для воплощения этого подхода мы использовали Python и библиотеку Pyknow. Эта библиотека предоставляет удобные инструменты для определения фактов и правил вывода, а также механизм для их автоматизированного применения. Одним из ключевых достоинств Pyknow является её интуитивно понятный интерфейс, делающий её доступной для широкого круга пользователей. Благодаря гибкости Pyknow, правила вывода и факты можно легко адаптировать под изменяющиеся условия, что делает систему эффективной и актуальной.

## Механизм вывода

Механизм прямого вывода представляет собой ключевую методику работы в экспертных системах. Это процесс, в котором используются уже известные факты для логического вывода новых данных и принятия обоснованных решений. Работа этого механизма осуществляется по следующим этапам:

Начальная Установка Фактов: На этом этапе формируется исходная база данных с начальными знаниями и фактами.

Анализ Правил: В этой фазе происходит оценка всех правил в контексте существующих знаний. Если правило соответствует текущим фактам, оно активируется.

Выполнение Активированных Правил: Активированное правило применяется для генерации нового факта или знания.

Обновление Базы Данных: Новый факт интегрируется в базу данных, что инициирует повторную проверку и активацию правил с учетом обновленной информации.

Завершение Процесса: Цикл логического вывода продолжается до тех пор, пока не будут получены все требуемые факты или не будет достигнуто предустановленное условие для остановки процесса.

## Код
```py
import sys
from pyknow import *

         
class Algoritmth(KnowledgeEngine):
    def __init__(self):
        super().__init__()

    @Rule(OR(
           AND(Fact('упорядочивание текста'),Fact('задача связана с текстом')),
           Fact('задача упорядочивания')))
    def sort(self):
        self.declare(Fact('Сортировка'))
        
    @Rule(AND(Fact('Сортировка'),Fact('нет информации о данных'), NOT(Fact('нужна стабильность'))))
    def quick(self):
        self.declare(Fact(algo='Быстрая сортировка'))
    
    @Rule(AND(Fact('Сортировка'), Fact('нет информации о данных'), Fact('нужна стабильность')))
    def merge(self):
        self.declare(Fact(algo='Сортировка слиянием'))
    
    @Rule(AND(Fact('Сортировка'), Fact('равномерное распределение данных')))
    def karman(self):
        self.declare(Fact(algo='Карманная сортировка'))
    
    @Rule(AND(Fact('Сортировка'), Fact('количество данных больше диапазона, в котором они заключены')))
    def count(self):
        self.declare(Fact(algo='Сортировка подсчетом'))
    
    @Rule(AND(Fact('Сортировка'), Fact('Алфавит входных сильно меньше кол-ва входных данных')))
    def radix(self):
        self.declare(Fact(algo='Поразрядная сортировка'))

    @Rule(AND(Fact('Уменьшить размер текста'), Fact('задача связана с текстом')))
    def text_zip(self):
        self.declare(Fact('Сжатие текста'))

    @Rule(AND(Fact('Сжатие текста'), Fact('неизвестные входные данные'), Fact('необходимо кодир повторяющиеся шаблоны данных')))
    def lzw(self):
        self.declare(Fact(algo='LZW'))

    @Rule(AND(Fact('Сжатие текста'), Fact('неизвестные входные данные'), Fact('необходимо кодир отдельные символы'))) # пересечение
    def haffman(self):
        self.declare(Fact(algo='Алгоритмы Хаффмана'))

    @Rule(AND(Fact('Сжатие текста'), Fact('Входные данные - длинная посл-ть повторяющихся символов')))
    def rle(self):
        self.declare(Fact(algo='RLE'))

    @Rule(AND(Fact('Поиск в тексте'), Fact('задача связана с текстом')))
    def substring(self):
        self.declare(Fact('Поиск подстрок'))

    @Rule(OR(AND(Fact('Поиск подстрок'), Fact('префикс-функция')), AND(Fact('Поиск подстрок'), Fact('текст похож на естественный язык'))))
    def kmp(self):
        self.declare(Fact(algo='КМП'))

    @Rule(AND(Fact('Поиск подстрок'), Fact('простая реализация')))
    def z_func(self):
        self.declare(Fact(algo='z-функция'))

    @Rule(AND(Fact('Деревья'), Fact('Поиск подстрок'))) #пересечение
    def trie(self):
        self.declare(Fact('Trie'))

    @Rule(AND(Fact('Trie'), Fact('Подстроки всегда одинаковые')))
    def axo_korasik(self):
        self.declare(Fact(algo='Ахо-Корасик'))

    @Rule(AND(Fact('Trie'), Fact('текст где ищем подстроки всегда один и тот же')))
    def patricia(self):
        self.declare(Fact(algo='PATRICIA'))
    
    @Rule(OR(
           AND(Fact('в задаче используется структура данных, предназначенная для хранения информации'),Fact('состоит из вершин'),Fact('состоит из рёбер')),
           Fact('задача связана с картами местности')))
    def graphs(self):
        self.declare(Fact('графы'))
        
    @Rule(AND(Fact('графы'),Fact('найти кратчайшее расстояние между элементами')))
    def graph_distance(self):
        self.declare(Fact('нахождение кратчайшего расстояния в графе'))

    @Rule(AND(Fact('нахождение кратчайшего расстояния в графе'),Fact('кратчайший путь между всеми парами вершин')))
    def floyd_warshall(self):
        self.declare(Fact(algo = 'алгоритм флойда-уоршалла'))
        
    @Rule(AND(Fact('нахождение кратчайшего расстояния в графе'),Fact('вес ребер должен быть неотрицательным')))
    def deikstra(self):
        self.declare(Fact(algo = 'алгоритм дейкстры'))
        
    @Rule(AND(Fact('графы'),OR(Fact('задача связана с поиском максимума'),Fact('задача связана с поиском минимума'))))
    def optimization(self):
        self.declare(Fact('задачи на оптимизацию'))
        
    @Rule(AND(Fact('задачи на оптимизацию'),Fact('выбор лучшего из решений подзадач приводит к решению всей задачи')))
    def jadniy(self):
        self.declare(Fact(algo='жадный алгоритм'))

    @Rule(AND(Fact('задачи на оптимизацию'),Fact('потребуется ли сохранить результаты предыдущих этапов')))
    def dp(self):
        self.declare(Fact(algo='динамическое программирование'))
        
    @Rule(AND(Fact('графы'),Fact('все вершины достижимы'), Fact('граф без циклов')))
    def tree(self):
        self.declare(Fact('Деревья'))
    
    @Rule(AND(Fact('Деревья'),Fact('необходимо определить наиболее экономичный способ соединения всех узлов')))
    def tree_min(self):
        self.declare(Fact(algo = 'поиск минимального остовного дерева'))
        
    @Rule(AND(Fact('Деревья'),Fact('необходимо иметь минимальное возможное время доступа к элементам')))
    def tree_balanced(self):
        self.declare(Fact('сбалансированные деревья'))
        
    @Rule(AND(Fact('сбалансированные деревья'),Fact('можно пожертвовать скоростью ради удобства написания кода')))
    def tree_decart(self):
        self.declare(Fact(algo ='декартово дерево'))
        
    @Rule(AND(Fact('сбалансированные деревья'),Fact('требуется использовать больше операций вставки и удаления чем поиска')))
    def tree_AVL(self):
        self.declare(Fact(algo ='КЧ дерево/AVL дерево'))
        
    @Rule(AND(Fact('сбалансированные деревья'),Fact('необходима эффективная работа с дисковой памятью')))
    def tree_B(self):
        self.declare(Fact(algo ='B дерево'))
    @Rule(Fact(algo=MATCH.a))
    def print_result(self,a):
          print('Алгоритм - {}'.format(a))
                    
    def factz(self,l):
        for x in l:
            self.declare(x)


if __name__ == "__main__":
    ex1 = Algoritmth()
    ex1.reset()
    ex1.factz([
        Fact('сбалансированные деревья'),Fact('можно пожертвовать скоростью ради удобства написания кода')])
    ex1.run()
```
Механизм прямого вывода использует базу фактов и правил, чтобы генерировать новые факты и принимать решения. Он позволяет экспертной системе использовать имеющиеся знания для вывода новых знаний и решения задач в автоматическом режиме.

## Извлечение знаний и база знаний

Извлечение знаний для данной работы было основано на общих знаниях, которые мы получили за последние два семестра, изучая дискретный анализ. Этот курс дал нам фундаментальное понимание теории алгоритмов, включая их структуры, принципы работы и методы классификации. С этим багажом знаний мы смогли подойти к задаче извлечения и систематизации информации о различных алгоритмах более осмысленно и целенаправленно.

Начало нашей работы заключалось в создании общего представления о различных категориях алгоритмов. Используя структуру дерева И-ИЛИ, мы классифицировали алгоритмы на основе их функций и применения. Например, в одной ветви дерева были сгруппированы алгоритмы сортировки, а в другой – алгоритмы для работы с графами. Это позволило нам визуализировать связи и иерархии между различными типами алгоритмов.

В процессе изучения литературы и научных источников, мы столкнулись с необходимостью извлечения знаний непосредственно из текста, особенно когда речь шла о более сложных и специализированных алгоритмах. В этих случаях мы опирались на наши общие знания, полученные в ходе курса, чтобы выделить ключевые характеристики и принципы работы каждого алгоритма.

При составлении базы знаний особенно интересным аспектом оказалось исследование применимости различных видов сбалансированных деревьев, включая Красно-чёрное дерево, AVL-дерево и B-дерево. До этого момента наша работа с этими структурами данных ограничивалась лишь их реализацией, но в процессе этого проекта мы углубились в анализ и понимание специфических ситуаций, в которых одно дерево может быть более предпочтительным, чем другое. 

Мы осознали, что выбор между Красно-чёрным деревом, AVL-деревом и B-деревом не просто техническое решение, а стратегический выбор, зависящий от конкретных требований задачи и особенностей данных. Например, AVL-деревья могут быть лучшим выбором в ситуациях, где требуется строгий баланс и высокая скорость поиска, в то время как Красно-чёрные деревья могут оказаться предпочтительнее в сценариях с частыми операциями вставки и удаления. B-деревья, с другой стороны, являются оптимальным решением для систем, работающих с большими объемами данных, особенно когда данные хранятся на внешних носителях.

Создание [дерева И-ИЛИ](https://miro.com/app/board/uXjVNk-MwUA=/) было трудоемким, но в то же время очень познавательным процессом. Это позволило нам не только глубже понять структуру и связи между различными алгоритмами, но и увидеть, как теоретические знания, полученные в университете, могут быть применены на практике.

## Протокол работы системы

### Пример 1

```Python
ex1.factz([
    Fact('задача связана с текстом'),
    Fact('Уменьшить размер текста'),
    Fact('неизвестные входные данные'),
    Fact('необходимо кодир повторяющиеся шаблоны данных'),
])
```

**Вывод:** Алгоритм - LZW

![image](https://github.com/MAILabs-Edu-2024/ai-lab-1-knowledge-representation-o-n-3-16/blob/main/img/Test1.png)

### Пример 2

```Python
ex1.factz([
    Fact('задача связана с текстом'),
    Fact('упорядочивание текста'),
    Fact('нет информации о данных'),
    Fact('нужна стабильность')
])
```

**Вывод:** Алгоритм - Сортировка слиянием

![image](https://github.com/MAILabs-Edu-2024/ai-lab-1-knowledge-representation-o-n-3-16/blob/main/img/Test2.png)

### Пример 3

```Python
ex1.factz([
    Fact('в задаче используется структура данных, предназначенная для хранения информации'),
    Fact('состоит из вершин'),
    Fact('состоит из рёбер'),
    Fact('все вершины достижимы'),
    Fact('граф без циклов'),
    Fact('необходимо иметь минимальное возможное время доступа к элементам'),
    Fact('необходима эффективная работа с дисковой памятью')
])
```

**Вывод:** Алгоритм - B дерево

![image](https://github.com/MAILabs-Edu-2024/ai-lab-1-knowledge-representation-o-n-3-16/blob/main/img/Test3.png)

## Выводы

В ходе создания экспертной системы у нас составилось мнение об этой работе и об экспертных системах в целом. Осознали, что такое занятие может быть долгим и монотонным, и большая часть работы по составлению базы знаний не всегда входит в область обязанностей программиста, чаще её 
выполняет эксперт по отрасли. В нашем случае использовалась система PyKnow, что позволило корректно реализовать логику на основе правил И-ИЛИ, однако ощутили недостаток в гибкости из-за отсутствия отрицаний в правилах, что могло бы существенно сократить объём перечисляемых условий.

Одним из основных вызовов стала необходимость интеграции большого объема информации и разработка интуитивно понятной системы классификации. Мы столкнулись с трудностью в отсеивании нерелевантной информации и акцентировании внимания на критически важных аспектах алгоритмов для их классификации.

Командная работа была ключевым фактором нашего успеха, она получилась эффективной за счёт мотивации участников и слаженности коллектива. 

В целом, эта лабораторная работа предоставила нам возможность не только применить теоретические знания на практике, но и развить навыки командной работы и проектного управления, что безусловно является важным аспектом в нашей будущей профессиональной деятельности.
